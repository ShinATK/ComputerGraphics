#cg #opengl

# OpenGL

OpenGL，API（Application programming interface，应用程序编程接口）

包含了一系列可以操作图形、图像的函数

OpenGL本身*并不是一个API*，它仅仅是一个由[Khronos组织](http://www.khronos.org/)制定并维护的**规范(Specification)**

## 核心模式与立即渲染模式

早期的OpenGL使用**立即渲染模式**（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。
- 大多数功能被库隐藏，自由度较低

OpenGL3.2开始废弃立即渲染模式，通过在OpenGL的**核心模式（Core-profile）** 下开发，完全移除旧的特性

## 扩展

扩展 extension

显卡公司提出的新特性或者渲染上的大优化，通常以扩展的方式在驱动中实现。


## 状态机

OpenGL是一个巨大的**状态机**（State Machine）：一系列的变量描述OpenGL此刻应当如何运行。

OpenGL的状态通常被称为**OpenGL上下文**（Context）

改变状态的方法：
- 设置选项
- 操作缓冲
- 使用当前上下文来渲染

**状态设置函数**（State-chaning Function），能够改变上下文
**状态使用函数**（State-using Function），根据当前状态执行一些操作

## 对象

OpenGL库是用C语言写的，内核始终为一个C库

OpenGL开发的时候引入抽象层，**对象**（Object）为其中之一

OpenGL中的**对象**：指一些选项的集合，是代表OpenGL状态的一个子集

使用OpenGL时常见的工作流：

```cpp
// 创建对象
unsigned int objectId = 0;
glGenObject(1, &objectId);
// 绑定对象至上下文
glBindObject(GL_WINDOW_TARGET, objectId);
// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项 
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800); 
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);
// 将上下文对象设回默认 
glBindObject(GL_WINDOW_TARGET, 0);
```

- 创建一个对象，将引用保存在一个id中
- 将对象绑定至上下文的目标位置
- 设置窗口的选项，被设置的对象会保存在objectId所引用的对象中
- 最后将目标位置的对象id设置为0，解绑对象，重新绑定时对应的选项就会生效


# 创建窗口

首先要做的事情：
- 创建一个OpenGL上下文 Context
- 创建一个用于显示的窗口

这里使用的库为`GLFW`

## GLFW

GLFW：一个专门针对OpenGL的C语言库，提供了一些渲染物体所需的最低限度的接口。
- 允许用户创建上下文
- 定义窗口参数
- 处理用户输入

### 构建GLFW

GLFW下载：[Download | GLFW](https://www.glfw.org/download.html)

这里将从编译源代码开始，源码包下载并解压。

明确需要的目标文件：
- 编译后生成的库
- include文件夹

从源码编译库可以保证生成的库完全适合自己的操作系统和CPU，而预编译的二进制文件则并非总是提供。

使用CMake来讲给定的.c/.cpp/.h/.hpp来自己构建项目/解决方案

### CMake

CMake：工程文件生成工具。通过预定义好的CMake脚本，根据自己的选择生成不同的IDE工程文件。

CMake下载：[Download CMake](https://cmake.org/download/)

安装后，可以从命令行或GUI启动CMake，这里使用GUI对下载的GLFW源代码进行编译。

![CMake界面](Pasted%20image%2020231202205720.png)

按照步骤进行：
- 选择源代码目录和存放编译结果的目录（build）
- configure
- 选择工程的生成器，这里使用VS2019，所以选择VS16选项
- 再次configure保存设置
- generate，工程文件生成在build文件夹中

### 编译

在build中打开GLFW.sln，将配置修改为64位，点击Build Solution，编译的库文件在`build/src/Debug`中

在IDE中添加库和头文件位置：
- 建立一个新目录包含所有第三方库和头文件，如
- OpenGL
	- Libs
	- Include

### 链接

此时还需要将GLFW库链接（Link）到工程，指定glfw3.lib

- 项目属性 - VC++ 目录
- 在Library Directories和Include Directiories中添加对应路径
- 再选择Linker - Input，Additional Dependencies中添加glfw3.lib库文件名

最后还需添加条目链接到OpenGL的库

### Windows上的OpenGL库

opengl32.lib已经包含在Microsoft SDK中，VS安装时已经默认安装，直接添加opengl32.lib即可

## GLAD

OpenGL只是一个标准/规范，具体实现是由驱动开发商针对特定显卡实现的。而OpenGL驱动版本很多，大多数函数的位置都无法在编译时确定下来，需要在运行时查询，所以需要GLAD简化这个过程。

### 配置GLAD

GLAD是一个[开源](https://github.com/Dav1dde/glad)的库

使用[在线服务](http://glad.dav1d.de/)来获得配置，提供需要定义的OpenGL版本。

![GLAD在线服务](Pasted%20image%2020231202205638.png)

- 语言设置：C/C++
- API选项：3.3以上，我个人选择的是4.5
- Profile设置：Core
- 确保选择了生成加载器（Generate a loader）
- 点击生成来获得库文件
- 下载压缩文件并解压：两个头文件目录，和一个**glad.c**文件
- 将两个glad、KHR头文件目录复制到先前建立的Include文件夹中
- 将glad.c添加到工程中


# Hello Window

确保GLAD的头文件在GLFW头文件之前，GLAD的头文件包含了正确的OpenGL头文件（例如`GL/gl.h`），所以需要在其它依赖于OpenGL的头文件之前包含GLAD。

- [01-hello-window](Graphics/LearnOpenGL/src/01-hello-window/main.cpp)


# Hello Triangle

- **顶点数组对象**：Vertex Array Object, VAO
- **顶点缓冲对象**：Vertex Buffer Object, VBO
- **元素缓冲对象**：Element Buffer Object, EBO
- **索引缓冲对象**：Index Buffer Object，IBO

OpenGL的工作，是将3D坐标转变为适应屏幕的2D像素的过程，由**图形渲染管线**（Graphics Pipeline）管理。

## 图形渲染管线

**图形渲染管线**两个主要部分：
- 3D坐标转换为2D坐标
- 2D坐标转变为实际的有颜色的像素

> **2D坐标和像素是不同的**
> 2D坐标：一个点在2D空间中的精确位置
> 2D像素：这个点的近似值，受屏幕分辨率/窗口分辨率的限制

图形渲染管线可以被划分几个具有*并行执行*特性的阶段，从而可以在GPU上为每一个（渲染管线）阶段运行各自的小程序，这些小程序叫做**着色器**（Shader）

OpenGL着色器是用**OpenGL着色器语言（OpenGL Shading Language，GLSL）** 写成的

下图，图形渲染管线的抽象示意图，其中的**蓝色**：代表可以注入自定义的着色器的部分

![图形渲染管线的抽象展示](Pasted%20image%2020231202211423.png)

### 渲染管线输入

绘制图形前需要输入顶点数据

- 顶点数据 Vertex data：以数组形式传递的3个3D坐标作为输入，表示一个三角形，一系列顶点的集合
- 顶点 Vertex：一个3D坐标数据的集合
- 顶点数据由**顶点属性**（Vertex Attribute）表示
- 这里暂时假定每个顶点由一个3D位置和一些颜色值组成

输入：一系列的顶点数据
过程：设置顶点属性
输出：顶点对象（3D位置+颜色值）

OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才进行处理，这个范围内的坐标叫做[标准化设备坐标 NDC](标准化设备坐标%20NDC.md)（Normalized Device Coordinates）

定义顶点数据：

```cpp
float vertices[] = { 
	-0.5f, -0.5f, 0.0f, 
	0.5f, -0.5f, 0.0f, 
	0.0f, 0.5f, 0.0f 
};
```

- 利用glGenBuffers函数和一个缓冲ID生成一个VBO对象
```cpp
// 利用glGenBuffers函数和一个缓冲ID生成一个VBO对象
unsigned int VBO;
glGenBuffers(1, &VBO);
```

顶点缓冲对象的缓冲类型：`GL_ARRAY_BUFFER`

- glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上
```cpp
glBindBuffer(GL_ARRAY_BUFFER, VBO);
```

- 调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：
	- 第一个参数是*目标缓冲的类型*：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上
	- 第二个参数*指定传输数据的大小*(以字节为单位)；用一个简单的`sizeof`计算出顶点数据大小就行
	- 第三个参数是*希望发送的*实际数据
	- 第四个参数指定了希望显卡如何管理给定的数据，三种形式
		- GL_STATIC_DRAW ：数据不会或几乎不会改变
		- GL_DYNAMIC_DRAW：数据会被改变很多。
		- GL_STREAM_DRAW ：数据每次绘制时都会改变。
```cpp
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```

现在我们已经把**顶点数据**储存在显卡的内存中，用**VBO**这个**顶点缓冲对象**管理。

### 顶点着色器

顶点着色器 Vertex Shader：着色器语言GLSL（OpenGL Shading Language）编写

- 输入：一个3D顶点坐标
	- 在GPU显存中使用**顶点缓冲对象**（Vertex Buffer Object，VBO）存储顶点数据，并配置OpenGL如何解释这些内存
		- 可以一次性发送一大批数据到显卡上
		- CPU发送到显卡相对较慢
		- **只要可能，每次都要尝试尽量一次性发送尽可能多的数据**
	- 指定如何发送给显卡
	- 顶点着色器可以立即访问显存中的顶点数据
- 过程：矩阵变换
- 输出：另一种3D坐标

一个非常基础的GLSL顶点着色器的源代码：
```cpp
// 以版本声明开始，和OpenGL版本匹配，core表示核心模式
#version 450 core 
// 关键字in，声明输入顶点属性 Input Vertex Attribute
// vec3：3个分量的vector，变量名为aPos
// layout (location = 0)：输入变量的位置值
layout (location = 0) in vec3 aPos;

void main()
{
	// gl_Postion则为顶点着色器的输出
	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
```

- [向量(Vector)](向量(Vector).md)

这里没有对输入数据做什么处理，真实的程序里通常都不是标准化设备坐标，所以需要首先把输入数据转换至OpenGL的可视区域里

### 编译着色器

将顶点着色器的源代码硬编码在代码文件顶部的C风格字符串中：

```cpp
const char *vertexShaderSource = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"void main()\n"
	"{\n"
	" gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";
```




### 目前暂不考虑

#### 图元装配

**图元**（Primitive）：指定这些数据所表示的渲染类型

Primitive Assembly

- 输入：顶点着色器输出的所有顶点作为输入
- 过程：对顶点进行装配
- 输出：指定的图元的形状

#### 几何着色器

Geometry Shader

- 输入：图元形式的一系列顶点的集合
- 过程：产生新顶点构造出新的图元
- 输出：其他形状



### 光栅化阶段

Rasterization Stage

- 输入：其他形状的图元
- 过程：映射到屏幕上相应的像素
- 输出：生成片段Fragment（裁切Clipping掉视图以外的像素，来提升效率）

**OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据**

### 片段着色器

Fragment Shader

- 输入：光栅化生成的片段
- 过程：计算光照、阴影、光的颜色等（OpenGL高级效果产生的阶段）
- 输出：一个像素的最终颜色

### Alpha测试和混合（Blending）阶段

- 输入：所有像素对应的颜色值
- 过程：
	- 检测片段对应的深度（和模板（stencil））值，判断前后关系
	- 检测alpha值（透明度），并对物体进行混合（Blend）
- 输出：最终的图片


> 大多数场合，只需要配置**顶点**和**片段着色器**就可以了
> 几何着色器是可选，通常使用默认


