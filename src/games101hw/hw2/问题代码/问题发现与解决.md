# 问题：修改hw2代码完成后运行，全黑，看不到三角形

使用 WinMerge 与正确代码反复对比发现是在 main.cpp 中，
计算空间范围时出错

具体情况如下：

在错误的代码中，根据 `eye_fov` 和 `z` 轴坐标计算 `top` 位置时，使用了 `far`，即选取了远平面的 `z` 轴数据进行了计算，如下：

```cpp
float half_eye_fov = 0.5 * eye_fov / 180.0 * MY_PI;
float top = zFar * tan(half_eye_fov);
```

正确的写法应该是：

```cpp
float half_eye_fov = 0.5 * eye_fov / 180.0 * MY_PI;
float top = zNear * tan(half_eye_fov);
```

使用 `zNear` 与 `tan(half_eye_fov)` 进行计算 `top`，修改后图像正常出现

# 为什么不能使用 `zFar` 而是要使用 `zNear` 计算呢？

重温视图变换章节内容，当我们进行透视投影变换操作时，可以将透视投影分解为多个步骤，数学矩阵形式如下：

$$M_{persp} = M_{ortho_scale} \cdot M_{ortho_translate} \cdot M_{persp_to_ortho}$$

注意这里的变换步骤，在上方出错的代码位置，这里计算的内容是正交变换操作，此时应当是已经完成了变换矩阵 $M_{persp_to_ortho}$ 所代表的操作。

故，当运算进行到代码位置时，物体已经被压缩，只剩下通过正交投影将物体投影成标准小立方体，其前后平面的高和宽已经一致。

并且在该代码所在的函数提供的形参 `eye_fov` 就是指的从相机/原点出发的视线与近平面最上最下位置的夹角大小，所以这里应该是用近平面的 `zNear` 进行计算 `top`。

通过修改代码为 `float top = (zFar * TIMES + zNear) * tan(half_eye_fov);` 修改 `TIMES` 分别为：1，0.5，0.1，0.05，0。观察运行结果，发现随着 `TIMES` 的减小，绘制的两个三角形逐渐靠近。说明之前的错误代码的运行结果，是三角形的绘制距离过远导致的黑屏。
